from models import ChatResponse
from config import app_logger
from fastapi import status as http_status, HTTPException
import json

from utils.prompts import prepare_feature_extraction_prompt, prepare_answering_prompt
from utils.search import search_in_index
from utils.system_messages import SYSTEM_MESSAGE_FEATURE_EXTRACTION, SYSTEM_MESSAGE_ANSWERING
from utils.utils import get_completion, rerank_contexts


class ChatModel:
    """
    This class represents the Chat model of the chatbot.

    Attributes:
        N/A

    Methods:
        - chat(*args, **kwargs): processes the chat request and provides a response based on the input.

    """

    def __init__(self, *args, **kwargs):
        """
        Constructs an instance of the ChatModel class.

        Args:
           *args: variable-length arguments.
           **kwargs: keyword arguments.

        Returns:
            None

        """
        super().__init__(*args, **kwargs)

    def chat(self, *args, **kwargs):
        """
        Processes the chat request and provides a response based on the input.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
                - input: the user's input.
                - history: the chat history.

        Returns:
            response: ChatResponse: The response object containing the status and data.
                status (str): The status of the response.
                data (dict): A dictionary containing the response generated by either the FAQModel or CarsModel
                             if exists.
                code (int): The status code of the response.
                error (dict): A dictionary containing the error message if exists.

        """
        user_input = kwargs.get('input')
        history = kwargs.get('history')
        app_logger.info(f"Input was received: '{kwargs.get('input')}'")
        features_prompt = prepare_feature_extraction_prompt(user_input)
        response_msg = get_completion(features_prompt,
                                      system_message=SYSTEM_MESSAGE_FEATURE_EXTRACTION,
                                      json_response=True)
        features = json.loads(response_msg)
        filters = {}
        sorting = []
        context = []
        top_results = -1

        if features:
            if features.get("begin_date") and features.get("begin_date") != "":
                filters["begin_date"] = features.get("begin_date")
            if features.get("end_date") and features.get("end_date") != "":
                filters["end_date"] = features.get("end_date")
            if features.get("sorting") and features.get("sorting") != "":
                sorting.append(f'date {features.get("sorting")}')
            if features.get("top_k") and features.get("top_k") != -1:
                top_results = features.get("top_k")
            app_logger.info(f"Extracted Features: `{str(features)}`")

            for i in range(len(features.get("queries"))):
                sub_contexts = search_in_index(query=features.get("queries")[i], filters=filters, search_parameters=features.get('keywords'), sorting=sorting,
                                        top_k=top_results)
                context.append(sub_contexts)
            context = rerank_contexts(context)

            gpt_prompt = prepare_answering_prompt(user_input, context[:3], language=features.get("language"))
            response_msg = get_completion(gpt_prompt, history=history, system_message=SYSTEM_MESSAGE_ANSWERING)
            response = ChatResponse(status="success", data={
                "response": response_msg
            })
            app_logger.info(f"AI Response is `{response.data.get('response')}`")
            return response
        else:
            raise HTTPException(status_code=http_status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Search Filters could not be extracted!")
